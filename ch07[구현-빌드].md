# 7. 빌드
- 지금까지 마이크로서비스의 설계 측면을 살펴봤다.
- 개발 프로세스는 어떻게 변경해야 할까?
- 이번장에서는 `파이프라인`과 `코드 관리`의 방법을 살펴본다.

## 7.1 지속적 통합에 대한 간략한 소개
- `지속적 통합`(CI, continous integration)
  - CI의 목표 : 기존 코드와 적절하게 통합되는지 확인
  - 코드커밋 감지, 체크아웃, 컴파일 테스트
- CI의 장점
  - 정적 분석 & 테스트를 사용해 코드 품질에 대한 피드백
    - SonarQube & junit
  - 바이너리 산출물 생성 자동화
    - Jenkins
  - 배포된 산출물로부터 역으로 코드 추적 가능(history)
  - IAC를 수용하면, `마이크로서비스 코드` 및 `인프라를 구성`하는데 필요한 코드 버전을 제어(빌드 & 복제)
    - Terraform
### 7.1.1 실제로 CI를 하고 있는가?
- CI 도구를 사용하는 것과 `CI를 수용하는 것을 혼동`
- 정말로 CI를 수용 하고 있는지 3가지 질문(제즈 험블)
  - `메인라인에 하루에 한번 체크인 하는가?`
    - 가능한 한 자주 단일 메인브랜치에 통합하라
  - `변경 사항을 검증하는 일련의 테스트가 있는가?`
    - 코드가 예상대로 동작하는지 확일할 수 없는 CI는 CI가 아니다.
  - `빌드가 깨졌을 때 이를 수정하는 것이 팀의 최우선 일인가?`
    - 빌드가 안된다면 추가 체크인을 모두 중지하며, 먼저 해결한다.
### 7.1.2 브랜치 모델
- 기능 브랜치(feature branch)
  - 변경 사항을 정기적으로 통합하지 않아, 통합을 지연시킨다.
  - 통합시 복잡한 머지를 해야한다.
- `트렁크 기반 개발`(trunk-based development)
  - 모든 사람이 동일한 트렁크에서 작업
  - 기능 플래그(feature flag)와 같을 기술을 사용해 미완 작업을 숨긴다.

- 
````
tip : 브랜치 주의 사항
1. 일찍 통합하고 자주 통합하라.
2. 기능 개발을 위해 장기 브랜치를 사용하지 말라.(브랜치를 꼭 사용해야 한다면 짧게 유지)
3. 트렁크 기반 개발을 고려하라.
````

## 7.2 빌드 파이프라인과 지속적 제공
### 7.2.1 도구
### 7.2.2 절충점과 환경
### 7.2.3 산출물 생성

## 7.3 소스 코드와 빌드를 마이크로서비스에 매핑하기
### 7.3.1 거대한 리포지터리 하나와 거대한 빌드
### 7.3.2 마이크로서비스당 하나의 리포지터리(멀티레포-패턴)
[리포지터리 간 코드 재사용]
[여러 리포지터리에서 작업]
[적용 대상]

### 7.3.3 모노레포(패턴)
### 7.3.4 어떤 방식을 사용해야 할까?

#### [요약]





