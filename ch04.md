# 4 마이크로서비스 통신 방식
- 다양한 통신 유형을 고려하지 못하여, 마이크로서비스 간의 통신을 제대로 구현하는 데 어려움이 따른다.
- 이번장에서는 문제 영역에 가장 적합한 통신 방식을 소개하고, 다양한 통신 방식을 분석해본다.
## 4.1 프로세스 내부에서 프로세스 사이로
- 네트워크를 통한 두 프로세스 사이의 호출은 한 프로세스 내부의 호출과 매우 다르다.
### 4.1.1 성능
- 프로세스 내 호출
  - 기본 컴파일러와 런타임은 호출의 영향을 줄이려고 마치 처음에 호출이 없었던것처럼 전체 호스트 최적화를 수행할 수 있다.
    - Just-In-Time 컴파일러(jvm), 인라이닝 - 실제 메소드를 호출하지 않고 바로 결과값을 돌려줌 (jvm)
- 프로세스 간 호출
  - 패킷을 전송해야한다.
  - 네트워크를 통해 마이크로서비스 간 호출을 할때 데이터는 직렬화/역직렬화를 하므로 페이로드의 크기에 대해 주의를 기울여야 한다.
### 4.1.2 인터페이스 변경
- 프로세스 내부 인터페이스 변경
  - `같은 프로세스에 함께 패키징`되어, 롤아웃이 간단하다.
- 마이크로서비스간 통신에서 인터페이스 변경
  - 하위 호환성을 깨뜨리는 변경을 할 때는 둘 다 새 인터페이스를 사용하도록 업데이트하기 위해 소비자와 함께 락스텝 배포를 한다.
### 4.1.3 에러 처리
- 프로세스 내부에서 에러의 특성은 매우 직관적인 편이다.
  - 호출 스택의 위 방향으로 에러를 전파한다.
- `분산 시스템에서 에러의 특성은 다양`하다.
  - 프로세스 간 통신에 나타나는 다섯 가지 유형의 실패 모드
    - `충돌 실패` : 프로세스나 시스템이 갑자기 중단되는 경우
    - `누락 실패` : 전송 후 응답을 받지 못하는 경우
    - `타이밍 실패` : 어떤 일이 너무 늦게 발생하거나 너무 일찍 발생한 경우
    - `응답 실패` : 응답이 예상한 것과 다른 경우
    - `임의 실패` : 비잔티움 실패, 비정상적인 동작으로 인해 발생하는 실패
## 4.2 프로세스 간 통신을 위한 기술:다양한 선택
- `프로세스 간 통신`에 사용하는 `기술의 범위는 방대`하다.
  - 기술에 대한 사고방식이 실제로 해결하려는 문제와 일치하지 않을 수 있다.
- 문제에 실제로 적합한지 고려하지 않고 신기술을 선택한다.
  - ex) 요청과 응답을 위해 카프카를 사용하는 것은 좋은 선택이 아니다.
- 따라서, 먼저 원하는 통신 방식을 이야기하고 나서 해당 방식을 구현하는 데 `적합한 기술`을 찾는 것이 중요하다.
## 4.3 마이크로서비스 통신 방식  
![image](https://github.com/jongwanS/building_microservices/assets/30585897/26338640-3d98-482f-9b53-fc99da97c2f3)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축 

- 동기식 블로킹(synchronous blocking)
  > 마이크로서비스는 다른 마이크로서비스를 호출하고 응답을 기다리는 작업을 차단한다.(다른 마이크로서비스 응답을 기다림)
- 비동기식 논블로킹(asynchronous nonblocking)
  > 호출을 보낸 마이크로서비스는 호출 수신 여부에 관계없이 처리를 계속할 수 있다.
- 요청 및 응답(request-response)
  > 마이크로서비스는 작업을 수행하도록 다른 마이크로서비스에 요청을 보낸다. 결과를 알려주는 응답을 받을 것을 기대한다.
- 이벤트 기반(event-driven)
  > 마이크로서비스는 다른 마이크로서비스가 소비하고 반응하는 `이벤트를 발산`한다. 이벤트를 발행하는 마이크로서비스는 자신이 발행하는 이벤트를 소비하는 마이크로서비스가 어떤 마이크로서비스인지 알지 못한다.
- 공통 데이터(common data)
  > 통신 방식으로 자주 볼 수 없는 마이크로서비스인 경우 `일부 공유 데이터 소스를 통해 협업`한다.


`신뢰할 수 있는 통신`, `허용 가능한 지연 시간`, `통신량`에 대한 요구 사항은 기술을 선택하는 데 중요한 역할을 한다.
- 주어진 상황에 더 적합한 방식이 `요청 및 응답` 인지 아니면 `이벤트 기반` 협업 방식인지 살펴본다.
- `요청 및 응답 방식`에서 동기 및 비동기 구현 모두가 가능하다면, `비동기 구현을 선택`해야한다.
- 하지만 `이벤트 기반 협업 방식을 선택`한다면, `비동기식 논블로킹 방식`으로 제한한다.
> 올바른 기술을 선택할 때는 통신 방식 외에도 지연시간 & 보안 관련 & 확장 기능 등 다양한 고려사항이 있다.

### 4.3.1 짜맞추기
- 마이크로서비스 아키텍처 전체에 다양한 협업 스타일이 혼재될 수 있으며, 이것은 지극히 일반적이다.
- 단일 마이크로서비스가 `하나 이상의 협업 형태를 구현하는 것은 일반적`이다.
  - ex) 주문하거나 변경하고 나서 이벤트를 발생시키는 주문(Order) 마이크로서비스가 있다. 
## 4.4 동기식 블로킹-패턴
- 마이크로서비스가 호출을 다운스트림 프로세스에 보내고 호출이 완료돼 `응답이 수신될 때 까지 대기`하는 형태  
![image](https://github.com/jongwanS/building_microservices/assets/30585897/3e229a1a-1be2-4579-9858-34a87a452b4d)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축 
### 4.4.1 장점
- 간단하고 친숙하다.
### 4.4.2 단점
- 시간적 결합
  - 주문 처리기가 멤버십을 호출할때 멤버십 마이크로서비스에 연결할 수 있어야 한다.
  - 다운스트림 마이크로서비스의 응답을 기다리고 있을 때, 응답이 늦거나 네트워크 지연 이슈가 있다면 오랜 시간 동안 블로킹 된다.
  - 멤버십 마이크로서비스가 부하를 받고 있고, 요청에 늦게 응답하면 주문 처리기도 느리게 응답하게 된다.
- 양방향 결합
  - 업스트림 인스턴스가 종료되면, 멤버신 마이크로서비스의 응답은 손실된다.
- 동기식 호출을 사용하면 비동기식 호출을 사용할 때보다 연쇄적인 문제에 더욱 취약해진다.
### 4.4.3 적용 대상
- 간단한 마이크로서비스 아키텍처라면 큰 문제가 없다.
- 호출 체인이 더 많아질 때 동기식 블로킹은 문제가 된다.
  - 긴 체인이 상당한 리소스 경합을 일으킬 수 있다.
  - 하나 또는 이들 간의 네트워크 호출에 문제가 발생하면 전체 작업이 실패 할 수 있다.
  - 업스트림 마이크로서비스의 네트워크 컨넥션을 응답이 올때까지 열린 상태로 유지해야하므로, 실행 중인 시스템에 영향을 줄 수 있다.  
![image](https://github.com/jongwanS/building_microservices/assets/30585897/0088663a-ef59-4238-b9c0-9b7b48ec9d52)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축 
- 이와 같은 상황을 개선하기 위해 마이크로서비스 간의 상호작용을 재검토 할 수 있다.
- 주문 처리기 마이크로서비스에서 이상거래 고객으로 지정하여 초기에 발견할 수 있다.
- 호출 체인의 길이를 줄여 전반적인 지연시간이 개선되는 것을 확인할 수 있다.
  - 구매 흐름의 이상거래 탐지 서비스를 제거해 의존성을 줄인다.  
![image](https://github.com/jongwanS/building_microservices/assets/30585897/ea2bf8c5-9e24-4314-a075-4e1bf169fe38)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축 
## 4.5 비동기식 논블로킹-패턴
- 비동기식 통신을 사용하면, 호출하는 마이크로서비스를 블로킹하지 않는다.
- 여러가지 비동기식 논블로킹 통신방식이 있지만, 책에서는 일반적인 3가지 비동기식 논블로킹 3가지방식을 소개한다.
#### 논블로킹 3가지 방식
1. 공통 데이터를 통한 통신
   - 업스트림 마이크로서비스는 공통 데이터를 변경하고, 이 데이터는 나중에 하나 이상의 마이크로서비스에서 사용된다.
2. 요청 및 응답
   - 마이크로서비스는 다른 마이크로서비스에 작업 요청을 보낸다. 요청된 작업이 완료되면 성공 여부와 관계없이 업스트림 마이크로서비스는 응답을 수신한다.
   - 특히, 업스트림 마이크로서비스의 어떤 인스턴스도 응답을 처리할 수 있어야 한다.
3. 이벤트 기반 상호작용
   - 마이크로서비스는 발행한 일에 대한 사실적 진술로 생각될 수 있는 이벤트를 브로드캐스트 한다.
   - 다른 마이크로서비스는 관심 있는 이벤트를 수신하고 적절히 대응한다.
### 4.5.1 장점
- 비동기식 논블로킹 통신을 사용하면 초기 호출을 수행하는 마이크로서비스와 호출을 수신하는 마이크로서비스는 일시적으로 분리된다.
  - 호출을 수신하는 마이크로서비스가 호출과 동시에 연결될 필요는 없으며, `시간적 비결합(2.3.1)에 대한 우려를 피한다`.
  - 호출에 의해 트리거되는 기능을 처리하는 데 오랜 시간이 걸리는 경우에도 유용하다.  
![img.png](images/ch04/img.png)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축 
### 4.5.2 단점
- 구현 복잡도와 비동기식 통신 방식의 선택 범위이다.
  - 선택 가능한 비동기 통신 방식은 다양하고, 구현 방식을 자세히 살펴보면 난감할지도 모를 기술들을 만날 수 있다.  
### 4.5.3 적용 대상
- 장기 수행 프로세스는 명백한 비동기 통신 후보다.(ex, 그림4-5)
- 긴 호출 체인이 있는 상황.

## 4.6 공통 데이터를 통한 통신 - 패턴(비동기식 논블로킹)
- 하나의 마이크로서비스가 데이터를 정의한 위치에 넣고(DB,fs system ..) 다른 마이크로서비스가 그 데이터를 이용하는 방식.  
  ![image](https://github.com/jongwanS/building_microservices/assets/30585897/96b58f54-0d8e-424a-994a-dfb89372ceac)
  출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축 
### 4.6.1 구현 //TODO
- 이 패턴을 구현하려면 데이터를 **저장할 영구 저장소가 필요**하다.
- 새 데이터가 가용하다는 사실을 인식하는 매커니즘이 필요
  - **폴링**(polling)방식이 가장 일반적인 해결책이다.
- 이 패턴의 두 가지 일반적인 예는 데이터 레이크(data lake)와 데이터 웨어하우스(data warehouse)이다.
  - 결합과 관련해서는 거리가 멀다.
  - 데이터 웨어하하우스 자체는 구조화된 데이터 저장소이다. 하위 호환이 불가능한 방식으로 변경되면 생산자가 업데이트 되어야 한다.?
 
![image](https://github.com/jongwanS/building_microservices/assets/30585897/51f2d26e-2361-4257-9365-df85fa4fa251)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축 
### 4.6.2 장점
- 일반적으로 알려진 기술을 사용해 매우 간단하게 구현할 수 있다.
- 다양한 유형의 시스템들과 함께 운용가능하다.
- 이방법은 데이터양에서도 큰 문제가 되지 않으므로, 한 번에 **많은 데이터를 전송한다면 효과적**이다.
### 4.6.3 단점
- 다운스트림의 소비자 마이크로서비스는 일종의 **폴링 매커니즘**을 통해 신규 데이터가 있음을 인식한다.
- 공통 데이터 저장소가 잠재적으로 **결합의 원천**이 된다.
  - 데이터 저장소의 구조가 변경되면 마이크로서비스 간 통신이 중단될 수 있다.
  - 통신의 견고성은 기본 데이터 저장소의 견고성에 따라 결정된다.
### 4.6.4 적용대상
- 사용 가능한 기술에 제약이 있는 프로세스 사이에서 상호 운용성을 활성화 할 경우.
  - 구형 시스템은 지원 가능한 기술에 제한이 있으며, 변경 비용이 많이든다.
    - gPRC인터페이스나와 통신하거나 카프카 토픽을 구독하게 만들면 편하지만 소비자 관점에서는 그렇지 않다.
    - 구형 시스템이라도 파일에서 데이터를 읽는 것은 가능하다.
- **대용량 데이터를 공유**할 수 있다는 점도 이 패턴의 장점이다.
  - 수 기가바이트 파일을 파일시스템으로 보내거나 데이터베이스에 수백만 개의 행을 로드해야한다면 이패턴이 적합하다.

## 4.7 요청 및 응답 통신 - 패턴(비동기식 논블로킹)
- 요청 및 응답을 사용하면 마이크로서비스는 다운스트림 서비스에 **작업 요청**을 보내고 요청에 대한 **결과를 받길 기대**한다.
  - 동기식 블로킹, 비동기식 논블로킹 방식 방식으로 구현 가능

- 일반적인 사용 사례
![image](https://github.com/jongwanS/building_microservices/assets/30585897/eb477a03-94bd-420f-8e0c-feae474d1149)
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축 

- 특정 순서로 호출을 완료해야하는 사용 사례
![image](https://github.com/jongwanS/building_microservices/assets/30585897/0e8ef379-1beb-4b46-9484-b8c9669ac8b0)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축 

- 명령 대 요청(용어 정리) - 필자는 요청이라는 용어를 선호
  - 명령 : 반드시 지켜야 하는 지시를 의미한다.
  - 요청 : 거부될 수 있따는 것을 암시한다.

### 4.7.1 구현:동기 대 비동기
- 요청 및 응답 호출은 **동기식 블로킹 방식**이나 **비동기식 논블로킹 방식**으로 구현할 수 있다.
- 동기식 블로킹
  - 업스트림 마이크로서비스가 응답할 때까지 대기하는 동안 커넥션이 열린 상태로 유지된다.
  - 응답하는 마이크로서비스는 요청하는 마이크로서비스에 대해 전혀 알 필요가 없다.
  - 다운스트림 마이크로서비스 인스턴스가 종료돼 커넥션이 끊어지면 문제가 발생할 수 있다.


![image](https://github.com/jongwanS/building_microservices/assets/30585897/62c1516a-52b7-47e3-85c9-72f3be7e369a)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축 
````java
1. 주문 처리기 서비스가 재고 예약 메시지를 큐로 전송
2. 창고 서비스는 가용한 상황에서 해당큐(재고 예약)를 사용
3. 창고 서비스는 주문 처리기 서비스가 읽고 있는 큐(재고 예약됨)로 응답을 보냄
  > 응답을 어디로 라우팅할지 알아야한다.
````

- 비동기식 논블로킹
  - 요청을 수신하는 마이크로서비스는 응답을 어디로 라우팅할지 알아야한다.
  - 큐를 사용하면 대기 중인 큐에 여러 요청을 버퍼링할 수 있는 이점이 있다.
    - 많은 호출에 압도되지 않고 준비가 되면 다음 요청을 소비할 수 있다.
  - 원래 요청과 응답을 연결 지어야할 때가 있다.
    - 응답이 요청을 보낸 동일 마이크로서비스의 인스턴스로 되돌아오지 않을 수 있으므로 원래 요청과 응답을 연결 짖는게 어려운 일이 될 수 있다.
      - 원래 요청과 관련된 모든 상태를 데이터베이스에 저장하고 응답이 올 때 상태를 다시 로드해서 적절히 동작하게 할 수 있다.


- **요청 및 응답의** 상호작용 형태에서는 블로킹 되는 문제를 피하고자 일종의 **타임아웃 처리가 필요**하다.

- 병렬 호출 대 순차호출
  - 여러 순차호출 API를 통해 서비스를 제공해야 할 경우, 병렬 호출로 고려하자.
    - ex) async/await 

### 4.7.2 적용대상
- 추가 처리가 일어나기 전에 **요청 결과를 확인해야 하는 모든 상황**에 적합하다.
- 재시도(retry)와 같은 **일종의 보상 조치를 수행** 가능한 마이크로서비스 환경에도 적합하다.

## 4.8 이벤트 기반 통신 - 패턴(비동기식 논블로킹)
### 4.8.1 구현
### 4.8.2 이벤트에 포함되는 것
### 4.8.3 적용 대상

## 4.9 조심해서 진행해라
