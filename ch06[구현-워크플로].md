# 워크플로
- 마이크로서비스 분산 트랜잭션
- 마이크로서비스 워크플로 모델링 할 수 있는 사가 패턴
## 6.1 데이터베이스 트랜잭션
- 트랜잭션을 단일 단위로 취급
  - 하나의 트랜잭션 내에서 전체가 실패하거나 성공한다.(일관성)

## 6.1.1 ACID 트랜잭션
- 데이터베이스 트랜잭션은 ACID 트랜잭션을 의미한다.
- ACID
  - `원자성(Atomicity)`
    - 트랜잭션 내 작업(DML)이 전체 성공 하거나 전체 실패 "All or Nothing"
  - `일관성 (Consistency)`
    - 데이터베이스가 변경되면, 유효하고 일관된 상태 유지(무결성, 칼럼타입, pk, fk ...)
  - `격리성 (Isolation)`
    - 여러 트랜잭션 간섭 없이 동시에 작동, 각 트랜잭션은 독립적으로 실행되는 것처럼 보이도록 보장
      - Dirty Read : 1번 트랜잭션이 데이터 수정(커밋전), 2번 트랜잭션이 데이터 조회시 1번 트랜잭션의 수정 내용을 2번 트랜잭션은 모른다.
      - Non-Repeatable Read : 1번 트랜잭션이 select 쿼리, 2번 트랜잭션이 update, 1번이 다시 select 했을때 2번트랜잭션이 반영한 데이터가 나온다.
      - Phantom Read : 하나의 트랜잭션이 범위 기반의 쿼리를 실행하는 동안 다른 트랜잭션이 같은 범위 내에서 데이터를 추가 또는 삭제하는 경우.
  - `지속성 (Durability)`
    - 트랜잭션이 성공적으로 완료된 후에는 해당 변경 사항이 영구적으로 저장

````
모든 데이터베이스가 ACID를 제공하는 것은 아님
> Neo4j 등
````
## 6.1.2 여전히 ACID이지만 원자성은 부족한가?
- 단일 ACID 트랜잭션

- 고객 및 등록 마이크로서비스 2개의 별도 트랜잭션
  - 각 자기 DB에 대한 ACID만 보장받는다.
  - 원자성 보장 X
## 6.2 분산 트랜잭션 - 2단계 커밋(Two-Phase Commit)
- 투표(voting) & 커밋(commit) 단계, 2가지 단계가 있다.
- `투표단계`
  - 중앙 조정자(coordinator)에서 트랜잭션에 참가할 `모든 워커`에 상태 변경 가능 여부 질의
    - 상태 변경 불가능시, 전체 연산 중단
- `커밋단계`
  -  


![image](https://github.com/jongwanS/building_microservices/assets/30585897/fbbc7859-3405-45b5-ad1c-21f0e9c03203)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  
````
tx1: 고객 상태 등록 보류 중 -> 확인 으로 변경요청
tx2: 등록 보류 삭제요청

- 둘중 하나라도 계약에 위반될 경우, 전체 연산 중단
- 전체 워커가 변경 승인후, 각 행은 로컬에서 잠긴다.
  -> 워커에 변경 승인 후, 계약위반사항이 발생할 수 있으므로

즉시 적용이 아닌, 미래 어느 시점에 해당 변경을 수행할 수 있음을 보장하는 것.
````

![image](https://github.com/jongwanS/building_microservices/assets/30585897/7277514d-8f34-455b-830c-3335b056bd18)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  
````
커밋 단계에서 변경 및 잠금 해제 된다.
-> 조정자는 커밋 요청을 모든 참가자에게 보냄.
-> 조정자의 메시지는 서로 다른시간에 처리되므로, tx1, tx2 가 다른 시간에 처리될 수 있다.

분산트랙잭션 처리로, ACID에서 `격리성` 이 사라졌다.
-> 워커A가 커밋, 워커B는 서비스 지연으로 늦게 커밋되어 둘의 처리 시점이 다를 수 있다.

하나 이상의 참여자가 실패를 보고했을 경우, 코디네이터는 롤백을 결정하고 이를 참여자들에게 통지

참여자가 많을수록. 잠금 범위가 클수록 엄청난 지연이 발생한다.
-> 수명이 매우 짧은 작업에만 사용한다.
````


## 6.3 분산 트랜잭션 - 그냥 안 된다고 하라
- 2단계 커밋과 같은 분산 트랜잭션은 피해야 한다.

- 분리할 묘수가 생각나지 않으면, 처음부터 데이터를 분리하지 않는다.
  - 다른부분 작업후, 다시 생각해본다.
- 그럼에도 불구하고 분산 트랜잭션을 사용해야 할때는 `사가` 패턴을 사용한다.

````
데이터베이스 분산 트랜잭션
- 구글 스패너 
````

## 6.4 사가 패턴
- `사가`는 전체 자원을 잠글 필요가 없다.
- `사가`를 사용하면 비즈니스 `프로세스를 명시적으로 모델링` 할 수 있는 이점 이 있다.
  - 프로세스의 유연성을 높이고, 명시적으로 모델링

````
사가는 원래 단일 데이터베이스에 대해 작동하는 LLT(장기트랜잭션)를 지원하기 위해 구상되었다.
> 장기트랜잭션을 하위 트랜잭션으로 나눔
````

````
주문 발생 예(2PC, 사가)
사가 : 주문 프로세스(주문,결제,재고) 트랜잭션을 단계별로로 나눌수 있다.
2PC : 주문 프로세스(주문,결제,재고) 모든 단계가 하나의 트랜잭션
````

![image](https://github.com/jongwanS/building_microservices/assets/30585897/e2d742d0-6d75-4e8a-8eea-30d144d87d2d)  
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  
## 6.4.1 사가 실패 모드
## 6.4.2 사가 패턴 구현
## 6.4.3 사가와 분산 트랜잭션의 비교








