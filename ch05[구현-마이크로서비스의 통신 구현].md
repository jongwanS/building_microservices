# 5. 마이크로서비스 통신 구현
- 이 장에서는 마이크로서비스 통신에 일반적으로 사용되는 몇 가지 기술을 살펴 본다.
## 5.1 이상적인 기술을 찾아서
- 마이크로서비스 간 통신하는 방법에는 `다양한 선택지`가 있다.
  - SOAP, XML-PRC, REST, gPRC 등
- 특정 기술을 논의하기 전에, 우리가 선택한 기술에서 `무엇을 원하는지 생각`해 봐야 한다.
### 5.1.1 하위 호환성을 쉽게 하라
- `마이크로서비스를 변경`할 때는 소비자 서비스와 `호환성이 깨지지 않도록` 해야 한다.
  - 이전 버전과 호환되는지 검증할 수 있는 기능 및 배포전 피드백
### 5.1.2 인터페이스를 명시적으로 만들라
- 마이크로서비스 소비자가 `노출된 기능을 명확하게 이해`할 수 있어야 한다.
  - `명시적 스키마` 사용하여 인터페이스를 정의하자.
    - ex) json 응답 형태의 문서 등등
### 5.1.3 API를 기술 중립적으로 유지하라
- 새로운 기술이나 도구가 항상 등장하며, 미래에는 현재 사용 중인 기술과 다를 수 있음
- 따라서, `API를 기술 중립적으로 설계`하는 것은 중요하다.
  - 기술 스택을 강요하는 통합 기술은 피해야 한다. 
  
### 5.1.4 소비자를 위해 서비스를 단순하게 만들라
- 소비자의 편의성 고려하여 `마이크로서비스의 사용을 단순`하게 만들어야한다.
- 소비자가 `자유롭게 기술 선택`할 수 있도록 해야 한다.
- 클라이언트 라이브러리를 제공하여, 편의성을 제공할 수 있으나 결합이 증가된다.

### 5.1.5 내부 구현 세부 사항을 숨겨라
- `상세 정보를 노출하도록 강요하는 기술`은 피해야 한다.
  - 소비자가 내부 구현에 종속되는 것을 피하기 위함
    - 기술 부채 및 변경 비용 증가 가능성

## 5.2 기술 선택
### 5.2.1 원격 프로시저 호출(remote procedure call)
- 어딘가에 있는 원격 서비스를 실행 하는 기술
  - SOAP, gPRC와 같은 명시적 스키마를 필요로 한다.
  [문제점]
  - 기술 결합 발생한다.
  - 로컬 호출은 원격 호출과 같지 않다.
  - 깨지기 쉽다.
  [적용대상]
  - 
### 5.2.2 REST
- 
### 5.2.3 그래프QL
### 5.2.4 메시지 브로커

## 5.3 직렬화 포맷
### 5.3.1 텍스트 포맷
### 5.3.2 바이너리 포맷

## 5.4 스키마
### 5.4.1 구조적 계약 위반 대 의미적 계약 위반
### 5.4.2 스키마를 사용해야 할까?

## 5.5 마이크로서비스 간의 변경 처리
## 5.6 중단 변경 피하기
### 5.6.1 확장 변경
### 5.6.2 관대한 독자
### 5.6.3 올바른 기술
### 5.6.4 명시적 인터페이스
### 5.6.5 우발적 중단 변경을 일찍 발견하기


## 5.7 중단 변경 관리하기
## 5.8 마이크로서비스 세계에서 DRY와 코드 재사용의 위험
## 5.9 서비스 디스커버리
## 5.10 서비스 메시와 API 게이트웨이
## 5.11 서비스 문서화


