# 5. 마이크로서비스 통신 구현
- 이 장에서는 마이크로서비스 통신에 일반적으로 사용되는 몇 가지 기술을 살펴 본다.
## 5.1 이상적인 기술을 찾아서
- 마이크로서비스 간 통신하는 방법에는 `다양한 선택지`가 있다.
  - SOAP, XML-PRC, REST, gPRC 등
- 특정 기술을 논의하기 전에, 우리가 선택한 기술에서 `무엇을 원하는지 생각`해 봐야 한다.
### 5.1.1 하위 호환성을 쉽게 하라
- `마이크로서비스를 변경`할 때는 소비자 서비스와 `호환성이 깨지지 않도록` 해야 한다.
  - 이전 버전과 호환되는지 검증할 수 있는 기능 및 배포전 피드백
### 5.1.2 인터페이스를 명시적으로 만들라
- 마이크로서비스 소비자가 `노출된 기능을 명확하게 이해`할 수 있어야 한다.
  - `명시적 스키마` 사용하여 인터페이스를 정의하자.
    - ex) json 응답 형태의 문서 등등
### 5.1.3 API를 기술 중립적으로 유지하라
- 새로운 기술이나 도구가 항상 등장하며, 미래에는 현재 사용 중인 기술과 다를 수 있음
- 따라서, `API를 기술 중립적으로 설계`하는 것은 중요하다.
  - 기술 스택을 강요하는 통합 기술은 피해야 한다. 
  
### 5.1.4 소비자를 위해 서비스를 단순하게 만들라
- 소비자의 편의성 고려하여 `마이크로서비스의 사용을 단순`하게 만들어야한다.
- 소비자가 `자유롭게 기술 선택`할 수 있도록 해야 한다.
- 클라이언트 라이브러리를 제공하여, 편의성을 제공할 수 있으나 결합이 증가된다.

### 5.1.5 내부 구현 세부 사항을 숨겨라
- `상세 정보를 노출하도록 강요하는 기술`은 피해야 한다.
  - 소비자가 내부 구현에 종속되는 것을 피하기 위함
    - 기술 부채 및 변경 비용 증가 가능성

## 5.2 기술 선택
대중적이고 흥미로운 몇가지 선택지를 다룬다.

#### 1. 원격 프로시저 호출(remote procedure call)
- 원격 프로세스에서 타 서버의 메서드를 호출할 수 있는 프레임 워크.
  - `SOAP`, `gRPC` 
#### 2. REST
- GET,POST 등을 사용해 리소를 노출하는 아키텍처 방식이다.
#### 3. 그래프QL(GraphQL)
- `클라이언트가 필요한 데이터의 구조를 요청`하는 방식
#### 4. 메시지 브로커(message broker)
- `큐`나 `토픽`을 통해 비동기 통신을 하는 미들웨어

### 5.2.1 원격 프로시저 호출
- `로컬에서 원격 서비스를 실행` 하는 기술
  - 원격서비스는 동일 로컬내 프로세스 또는 물리적으로 떨어진 서버가 될 수 있다.
- SOAP, gPRC와 같은 명시적 스키마를 필요로 한다.  
### [문제점]
1. `기술 결합`(technology coupling)이 발생한다.
   - 특정 프로그래밍 언어나 기술 스택에 의존(Java RMI)
     - 최근에는 gRPC, Apache 스리프트 언어 호환이 잘되긴 한다.

2. 로컬 호출은 원격 호출과 같지 않다.
   - 로컬 호출 : 같은 프로세스 내에서 메서드를 호출
   - 원격 호출 : 물리적으로 다른 위치에 있는 메서드를 호출
     - 네트워크를 통해 데이터를 전송, 마샬링과 역마샬링 과정필요(`네트워크 비용 고려`)
     - 네트워크는 신뢰할 수 없다.(패킷변조, 통신 실패 등)
3. 깨지기 쉽다.
   - `인터페이스 변경에 대한 취약성`
     - 인터페이스에 변경(메서드 이름 or 매개변수..)이 발생하면 클라이언트 및 서버 모두가 반영 필요
   - `데이터 구조 변경에 대한 취약성`
     - 데이터 구조에 새로운 필드를 추가하거나 기존 필드를 제거하는 경우, 클라이언트 및 서버 모두가 반영 필요

### [적용대상]
- `동기식 요청 및 응답` 모델
  - gRPC 추천
    - 비동기식 API지원
    - 플랫폼 호환성, 다양한 통신방식 등

### 5.2.2 REST
- 레벨 0: POX(Plain Old XML)
  - 첫 번째 단계에서는 HTTP를 단순히 전송 수단으로 사용합니다. RESTful한 개념에 대한 인식이 없으며, 단순히 HTTP GET, POST, DELETE와 같은 메서드를 사용하여 데이터를 전송합니다.  
- 레벨 1: 리소스 식별(URI)
  - 두 번째 단계에서는 각 리소스에 대해 유일한 식별자(URI)를 사용하여 리소스를 표현합니다. 이로써 각 리소스에 대한 고유한 경로를 제공하게 됩니다.
- 레벨 2: HTTP 메서드 활용
  - 세 번째 단계에서는 HTTP 메서드(GET, POST, PUT, DELETE 등)를 적절하게 활용하여 CRUD(Create, Read, Update, Delete) 작업을 수행합니다. 이로써 RESTful한 API의 기본적인 특성을 활용하게 됩니다.
- 레벨 3: 하이퍼미디어 컨트롤(HATEOAS)
  - 네 번째 단계에서는 하이퍼미디어 컨트롤(Hypermedia as the Engine of Application State, HATEOAS)을 적극적으로 활용합니다. 이는 클라이언트가 서버로부터 받은 리소스를 통해 애플리케이션의 상태를 이해하고 다음 가능한 동작을 결정할 수 있게 해줍니다.

### [REST와 HTTP]
- REST : 리소스를 정의하고 이 리소스에 대한 상태를 전송하는 방법에 중점을 둔 아키텍처적인 접근 방식
- HTTP

### 5.2.3 그래프QL
### 5.2.4 메시지 브로커

## 5.3 직렬화 포맷
### 5.3.1 텍스트 포맷
### 5.3.2 바이너리 포맷

## 5.4 스키마
### 5.4.1 구조적 계약 위반 대 의미적 계약 위반
### 5.4.2 스키마를 사용해야 할까?

## 5.5 마이크로서비스 간의 변경 처리
## 5.6 중단 변경 피하기
### 5.6.1 확장 변경
### 5.6.2 관대한 독자
### 5.6.3 올바른 기술
### 5.6.4 명시적 인터페이스
### 5.6.5 우발적 중단 변경을 일찍 발견하기


## 5.7 중단 변경 관리하기
## 5.8 마이크로서비스 세계에서 DRY와 코드 재사용의 위험
## 5.9 서비스 디스커버리
## 5.10 서비스 메시와 API 게이트웨이
## 5.11 서비스 문서화


