# 13 확장
- 시스템 확장 2가지 이유
  - **더 많은 부하** 처리, **지연시간 개선**
  - **시스템 견고성 개선**

## 13.1 확장의 네가지 축
- 확장 육면체(Scale Cube), `The Art of Scalability`  
  - 기능 분해, 수평 복제, 데이터 파티셔닝 3가지 범주로 세분화
  - 수직 확장에 대한 이야기는 없지만, 마이크로서비스 아키텍처를 가장 잘 **확장**할 수 있는 유용한 매커니즘 이다.
  ![1](./images/ch13/scale_cube.png)    
  출처 : https://isamatov.com/scale-your-app-better-with-scaling-cube/  

- **수직 확장(vertical scaling)**
  - 더 큰 머신을 사용하는 것
- **수평 복제(horizontal duplication)**
  - 동일한 작업을 수행하는 여러 대의 기기를 두는 것(인스턴스 추가)
- **데이터 파티셔닝(data partitioning)**
  - 데이터의 일부 속성에 따라 작업을 나누는 것.
- **기능 분해(functional decomposition)**
  - 마이크로서비스와 같이 업무를 분리하는 것.

### 13.1.1 수직확장
- 큰 머신을 사용하면 **지연 시간**(latency)과 **처리량**(throughput)이 향상돼 시간 대비 더 많은 작업을 처리할 수 있다.
- 과거에는 수직확장을 위해 하드웨어 구매, 실제 필요한 크기보다 더 큰 규모로 정하는 일이 흔했다.
- **가상화 및 공용 클라우드** 등장으로 **수직확장**이 수월 해졌다.

#### [구현]
- 구현 방법은 **실행 중인 인프라스트럭처**에 따라 다르다.
  - `가상화` => VM 크기 조정
  - `베어메탈(bare metal) 서버` => 더 좋은 하드웨어 구매
    - 베어메탈 : 한 소비자 또는 테넌트만 사용하는 물리적 컴퓨터 서버를 임대(클라우드 서비스의 한 형태)
  - `클라우드` => 목적에 맞는 다양한 머신 선택, 간단하고 빠르게 확장 가능

#### [주요 이점]
- 가상화된 인프라스트럭처(공용 클라우드 제공업체) **수직확장을 빠르게 구현** 할 수 있다.
  - 수직 확장은 빠르고 안전하게 시도할 수 있는 장점이 있다.
- `수직 확장`을 통해 다른 확장 유형들을 더 쉽게 수행 가능 하다.
  - 데이터베이스 인프라스트럭처를 더 큰 머신으로 옮기면, 논리적 데이터베이스(마이크로서비스용)를 더 많이 호스팅 가능하다.
- `수직 확장`시 **코드나 데이터베이스를 변경할 필요 없다.**
  - 변경된 하드웨어 활용시, 런타임 플래그로 메모리양을 늘릴 수 있다.

#### [제한 사항]
- `수직 확장`시, CPU가 빨라지는게 아니라, 코어 수만 증가한다.
  - 소프트웨어가 멀티코어 하드웨어를 활용하지 못하는 경우가 많다.
- 더 큰 시스템이 무조건 **견고성을 개선하지는 않는다.**
- 더 큰 머신일수록 비용이 증가하지만, **가용 자원이 증가가 항상 비례하지는 않는다.**
  - 소수의 대형 머신보다 다수의 소형 머신이 더 비용 효과적일 수 있다.

### 13.1.2 수평 복제
- `수평복제`는 단순한 편에 속하며, 초기에 시도하는것 중 하나다.
  - 모놀리식 시스템 부하가 있다면, 수평 복제를 시도하는 것도 좋은 방법이다.

#### [구현]
- **로드 밸러서를 통해 여러 복제본으로 요청 분산**
  - 과거에는 로드 밸런서를 전용 하드웨어의 관점에서 주로 생각 했다.
  - 최근에는 더 많은 로드 밸런싱이 클라이언트 측에서 실행되는 경우가 많다. (envoy)  
  ![1](./images/ch13/img.png)    
  출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

  - [그림 13-2] 뮤직코프에 새로운 노래가 업로드 되는 사진이다.
    - 노래 트랜스코더 서비스 인스턴스들이 작업을 두고 경쟁
    - 처리량 증가를 위해 인스턴스를 추가할 수 있다.  
    ![1](./images/ch13/img_1.png)     
    출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

  - [그림 13-3] 푸드코의 DB 수평복제
    - 읽기 복제본 라우팅은 마이크로서비스 내부적으로 처리  
    ![1](./images/ch13/img_2.png)    
    출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축   

- **경쟁 소비자 패턴**

#### [주요 이점]
- 수평 복제는 비교적 간단하다.

#### [제한 사항]
- 많은 인프라스트럭처가 필요 => 더 많은 비용 발생
- 수평복제는 부하 분산 매커니즘이다
  - 고정 세션이 필요한 경우 부하 분산 메커니즘이 제한될 수 있다. 

### 13.1.3 데이터 파티셔닝
- `데이터 파티셔닝`은 데이터의 일부 측면을 기반으로 부하를 분산시킨다.
- 예시 mysql 샤딩
  - https://www.youtube.com/watch?v=8Eb_n7JA1yA&t=208s&pp=ygUVbXlzcWwgZGIg7YyM7Yuw7IWU64ud
#### [Horizontal Partitioning]  
![1](./images/ch13/horizontal_partitioning.png)   
출처 : https://www.baeldung.com/cs/databases-horizontal-vertical-partitioning  

#### [Vertical Partitioning]  
![1](./images/ch13/vertical_partitioning.png)      
출처 : https://www.baeldung.com/cs/databases-horizontal-vertical-partitioning   

#### [Sharding]   
- 수평 vs 샤딩  
![1](./images/ch13/horizontal_example.png)    
출처 : https://www.youtube.com/watch?v=P7LqaEO-nGU     
![1](./images/ch13/sharding.png)   
출처 : https://www.youtube.com/watch?v=P7LqaEO-nGU

#### [replica]  
![1](./images/ch13/replica.png)    
출처 : https://www.youtube.com/watch?v=P7LqaEO-nGU

#### [구현]
[키에 함수를 적용한 파티션]
- 워크로드와 관련된 키를 가져온 후, `키에 함수를 적용`하여 **얻은 파티션(샤드)에 부하를 분산**
- 예를들어, [그림 13-4] 성을 기준으로 두 파티션으로 나눠 부하를 분산한다.  
![1](./images/ch13/img_3.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

[인스턴스 레벨 파티셔닝]
- 인스턴스 수준에서 파티셔닝도 가능하다. 
- 인바운드 요청으로부터 프록시를 통해, 어떤 파티션에 매핑되어야 하는지 파악가능하다.
- 예를들어, [그림 13-5]는 고객 요청헤더에 이름을 통해 인스턴스 매핑 시킨다.  
![1](./images/ch13/img_4.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축

[지리적 기준 파티셔닝]
- 국가별 지역별로 파티션을 만들 수 있다.

> **데이터 파티셔닝을 구현했다는 사실은 해당 마이크로서비스 내부의 구현 세부 사항으로 취급**돼야 한다

#### [주요 이점]
- `데이터 파티셔닝`은 **트랜잭션 워크로드에 유용**하게 확장 가능하다.
  - 쓰기 제약이 있는 시스템의 경우 큰 개션 효과를 얻을 수 있다.(각 파티션이 독립적으로 트랜잭션을 처리하기 때문)
- `데이터 파티셔닝`은 **유지 보수 활동의 영향도와 범위**를 쉽게 줄일 수 있다.
  - 파티션별 업데이트, 다운타임이 필요한 작업도 단일 파티션에만 영향
- `데이터 파티셔닝`은 **수평 복제와 함께 잘 동작**한다.
  - 각 파티션은 해당 작업을 처리하는 여러 노드로 구성될 수 있다.

#### [제한 사항]
- `데이터 파티셔닝`은 **시스템 견고성을 개선하는 데 한계**가 있다.
  - 예를들어, 4개의 파티션중 하나의 파티션이 다운되면 25%의 요청은 실패하게 된다. 
  - 데이터 파티셔닝과 **수평 복제 기술을 결합**해 특정 **파티션의 견고성을 향상**시킨다.
- `파티션 키`를 **올바르게 설정하는 것은 어렵다.**
  - 키를 잘못선정한다면, 부하가 고르게 분산되지 않을 수 있다.
  - 고객에게 부여된 고유 ID를 기반으로 파티셔닝 분할 => 부하를 균등하게 분산 가능성이 높다.

> 데이터베이스 선택 기준 책 추천 
> - NoSQL : 빅 데이터 세상으로 떠나는 간결한 안내서  

### 13.1.4 기능 분해
- `기능을 분해`하면 **독립적으로 확장**할 수 있다.
- [그림 13-6]은 주문 기능을 모놀리식 시스템에서 추출한 예시이다.
![1](./images/ch13/img_5.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

#### [구현]
- 3장 참조.

#### [주요 이점]
- 워크로드를 분리했으므로, **인프라스트럭처의 크기를 조정**할 수 있다.
  - 부하가 크지 않은 기능은 소규모 머신에 배포할 수 있다.
  - 부하가 큰 경우 수평 복제를 통해 부하를 분산시킬 수 있다.
  - `비용 최적화`하는 데 유연성을 확보할 수 있다.
- 기능 분해를 통해 **다양한 기술을 사용할 기회**가 늘어난다.
  - `서비스 유형`에 맞는 **데이터베이스 선택** 등

#### [제한 사항]
- `기능 분해`는 **복잡**하며, 단기간에 이점을 제공하기 어렵다.
  - `프론트&백엔드 코드에 가장 큰 영향`을 미칠 수 있는 확장 방식이다.
- `기능 분해`는 **시스템의 전반적인 복잡성을 증가**한다.
  - 유지 관리, 견고성 확보, 확장 등 필요한 항목이 더 많아진다.
- 필자는 시스템 확장시 `기능적 분해 이전`에 **다른 가능성 부터 모두 고려**한다.

## 13.2 결합모델
- `확장 육면체의 의미`는 한 가지 유형의 확장으로 좁게 생각하는 것을 지양하며, **필요시 축에 따라 애플리케이션을 확장하는것을 돕기 위한 것**이다.

- [그림 13-7] 주문 마이크로서비스를 여러 복제본으로 분리해 확장  
  ![1](./images/ch13/img_6.png)      
  출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

- [그림 13-8] 서로 다른 지리적 위치에 따른 주문 마이크로서비스
  - 수평 복제는 각각의 지리적 경계 안에서 적용된다.   
  ![1](./images/ch13/img_7.png)      
  출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축    

- **한 축을 확장**하면 **다른 축을 더 쉽게 활용**할 수 있다.
  - 주문 기능을 분해(기능분해) => 주문 처리 부하 분산(수평복제)
- 확장시 다양한 매커니즘이 있다는 점을 인식해야 한다. => 수평 복제, 수직복제, 데이터 파티셔닝, 기능분해
  - 각 매커니즘의 장단점을 이해하여 적합한것을 파악해라!

## 13.3 작게 시작하라
- 존재하지 않는 문제를 위해 **시스템을 최적화**하는 것은 `시간효율성이 좋지 않고`, `더 복잡한 시스템을 만드는 지름길`이 된다.
  - 따라서, **모든 형태의 최적화는 필요에 의해 주도돼야 한다.**
  - 도널드 크누스, The Art of Computer Programming
    - `프로그래머들이 엉뚱한 곳에서 시간 효율성에 대해 걱정하는데 많은 시간을 소비한다. 조기 최적화는 프로그래밍에서 악의 근원이다.`
- 병목 현상 파악 이후, **추가 작업이 합당한지 확인**하려면 **실험 과정이 필수적**이다.
  - 문제라고 인식했다면, 제안한 솔루션이 효과가 있는지 확인하기 위해 **수행 가능한 작은 작업을 찾아보라.**

> **CQRS와 이벤트 소싱**
> - `명령과 조회의 책임 분리(Command Query Responsibility Segregation, CQRS)` **읽기 및 쓰기에 대한 책임을 별도의 모델에서 처리하는 매커니즘**이다.

## 13.4 캐싱
- **캐싱(caching)은 성능 최적화 방법**으로, 후속 요청에 대해 **저장된 값을 사용할 수 있게 해준다.**
  - 예를들어, 캐시를 적용하여 추천 서비스가 재고 수준을 조회시 1차적으로 `로컬 캐시`에서 조회
    - 필요한 항목 발견시 **캐시 히트(cache hit)로 간주**
    - 데이터를 찾기 못하면 **캐시 미스(cache miss)이므로** 재고 마이크로서비스에서 정보를 가져온다.
- 캐시는 지연 시간을 줄이고, 애플리케이션을 확장, 시스템 성능을 개선하는 데 도움이 된다.

### 13.4.1 성능을 위해
- 마이크로서비스 사용시, 여러 마이크로서비스와 상호작용해야 하는 비용을 우려하는 경우가 많다.
- **캐시에서 데이터를 가져오면 네트워크 호출 없어져**, `다운스트림 부하를 줄이는데 큰 도움`이 된다.

### 13.4.2 확장성을 위해
- 읽기를 캐시로 전환하면 시스템 경합을 피해 **더 나은 확장성을 확보**할 수 있다.
  - 예를들어, 데이터베이스 읽기 복제본을 사용 => 주 데이터베이스 부하 줄어, **읽기를 효과적으로 확장**
- `확장성`을 위한 캐싱은 원본이 **경합 지점이 되는 상황에서 유용**하다.
- `클라이언트와 원본 사이에 캐시를 배치`하면 **원본의 부하를 줄여 확장성을 높일 수 있다.**

### 13.4.3 견고성을 위해
- 로컬 캐시에 전체 데이터 집합이 있다면, 원본이 가용하지 않을 경우에도 작동할 수 있다. => **견고성 향상**
- `견고성을 위한 캐싱` 사용시 **주의 사항**이 몇 가지 있다.
  - 캐시 무효화 이전까지는 **데이터를 캐시에 보관**해야 한다.
  - 원본이 오프라인일 경우에 **오래된 데이터라도 읽어올 준비를 해야 한다.**
  - 원본을 사용할 수 없는 상황에서, `로컬 캐시를 통해 견고성을 확보`하는 것은 일관성보다 **가용성을 우선시**한다는 의미이다.

### 13.4.4 캐싱 위치
- 캐시를 저장할 수 있는 다양한 장소가 있다.
- `최적화 유형`에 따라 **가장 적합한 캐시 장소를 찾을 수 있다.**
- [그림 13-9] 캐시 적용 장소 선정 상황 예시
  - 판매 마이크로서비스에 지난 7일간 판매된 사우이 10개 베스트셀러 목록 요청
  - 판매 마이크로서비스는 CD의 이름을 알지 못하고 ID 만 알고 있다.
  - 카탈로그 서비스를 통해 CD의 이름을 알아야 하는 상태이다.  
  ![1](./images/ch13/img_8.png)    
  출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

#### [클라이언트 측 캐싱]
- `클라이언트 측 캐싱` 사용시, 데이터는 **원본 범위를 벗어난 곳에 캐싱**된다.
- [그림 13-10]과 같이 인메모리 해시테이블을 통해 캐싱 처리한다.
  - CD와 관련된 내용 캐시 히트시, 카탈로그 호출 불필요.
- `클라이언트 측 캐싱`은 **지연시간 개선**, **견고성**을 위한 캐싱에도 적합하다.  

![1](./images/ch13/img_9.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축

---
- `클라이언트 측 캐싱` **단점**
  - 첫째, 무효화 메커니즘 선택 범위가 제한된다.
  - 둘째, 클라이언트 사이에 불일치 발생
    - 판매/프로모션/추천 프로모션 서비스 서로다른 캐시 데이터 => 알림 기반 무효화 but, 완전히 해소X 
    - [그림 13-11] 클라이언트 측 캐시를 공유 하거나, 레디스/멤캐시드 를 사용하여 완화시킬 수 있다. => 클라이언트간 불일치 해소
    - 하지만, 공유 캐시는 클라이언트 측 캐싱과 서버 측 캐싱 사이의 경계를 모호하게 만든다.
      - 캐시 데이터가 어느 쪽에서 관리되고 제공되는지 명확하지 않게 된다 //TODO


![1](./images/ch13/img_10.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

#### [서버 측 캐싱]
- [그림 13-12] 서버 측 캐싱을 사용하는 예시를 보여준다. 
  - `카탈로그 서비스`는 **캐시 관리에 대해 책임**진다.
  - 인메모리 데이터 구조, 로컬 캐싱 노드 등을 활용한다. 
    - **정교한 캐시 무효화 매커니즘을 구현하기가 더 용이** 하다.
    - **연속 쓰기 캐시**(write-through cache) 상황에서도 구현이 훨씬 간단하다. //TODO
  - `클라이언트 측 캐싱` **불일치 해결**할 수 있다.
- 마이크로서비스 인스턴스 코드에서 캐싱을 구현해야 한다는 의미는 아니다.
  - 역방향 프록시, 레디스, 읽기전용 데이터베이스의 복제본으로 전환
- `서버 측 캐싱` 문제점은 소비자 서비스가 네트워크 호출을 하므로 지연 시간 최적화 범위가 줄어든다.
- `서버 측 캐싱`은 전체적인 견고성을 상대적으로 감소 시킨다.
- 서버 측 캐싱이 도움이 될지 여부는 지연 시간 최적화와 같은 우려 사항에 따라 결정된다.
  - 클라이언트 측 캐싱이 더 많은 성능 이점을 제공할 수 있다.

![1](./images/ch13/img_11.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

#### [요청 캐시]
- `요청 캐시`는 **원본 요청에 대한 응답을 캐싱**해 저장한다.
  - **속도 최적화 측면에서 가장 효과적인 캐시 방법**이다.
- 매우 효율적인 캐싱 방법이지만, 요청의 결과만 캐싱하기 때문에 매우 **한정적인 캐싱 방법**이다.
  - 카탈로그 서비스를 호출하는 다른작업들은 캐싱되지 않는다. 

![1](./images/ch13/img_12.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

### 13.4.5 무효화
> 필 칸튼
> - 컴퓨터 과학에서 어려운 것은 **캐시 무효화**와 **작명**, 이 두가지 뿐이다.

- `무효화`는 캐시에서 데이터를 제거하는 과정이다.
  - 구현 방법은 다양하다.
- `무효화`를 **어떤 상황에서 진행**해야하는지 결정하는 것이 중요하다.

#### [TTL]
- `TTL(time to live)`은 캐시 무효화에 사용하는 **가장 간단한 매커니즘** 중 하나다.
  - 시간이 만료되면 데이터는 무효화되고 새 사본을 가져온다.
  - TTL 유효기간 및 타임스탬프를 사용하여 만료처리 한다.
- `HTTP`는 **TTL**(Cache-Control 헤더)과 **응답의 Expires 헤더**를 통해 캐싱을 지원한다.
  - 다운스트림 클라이언트가 데이터를 얼마나 오랫동안 최신으로 간주해야 하는지 알려 줄 수 있다.
- `TTL 기반 무효화의 한 가지 문제점`은 **그다지 정교하지 못하다는 점**이다.
  - 예를들어, 5분 동안 캐싱시에 5분동안 오래된 데이터로 작동 => **TTL 절충점 필요**

#### [조건부 GET]
//TODO
- HTTP는 응답에 Cache-Control 및 Expires 헤더를 지정해, **클라이언트 측 캐싱**을 제공한다.
- HTTP는 ETag라는 기능을 제공한다.
  - ETag는 리소스 값이 변경됐는지 여부를 확인한다.
- ETag는 조건부 GET(condition GET)을 사용할 때 강력해진다.
  - GET 요청시, 추가 헤더를 지정해 특정 기준이 충족되는 경우에만 클라이언트에 자원을 내려보도록 서비스에 지시할 수 있다.
- **어떤 경우에 조건부 GET이 유용**할까?
  - 응답을 만드는 데 많은 비용이 들고, 값비싼 DB 쿼리 집합 수행시 조건부GET을 통해 캐싱효과를 가져갈 수 있다.

#### [알림 기반]
- **알림 기반 무효화**(notification-based invalidation)은 이벤트를 통해 구독자가 **로컬 캐시 항목을 무효화할지 여부**를 알 수 있게 해준다.
- `TTL 기반 무효화`와 비교해 **상대적으로 복잡**한 단점이 있다.
- [그림 13-14] 추천 서비스는 클라이언트 캐시 사용하고 있다.
  - 캐시는 재고 서비스 => 이벤트 발행시 무효화 된다.

![1](./images/ch13/img_13.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축
- `알림 기반 무효화`는 오래된 데이터를 제공할 가능성을 줄인다.
- `단점`은 **구현이 복잡**하다.
  - 알림을 발행 및 구독처리를 해야한다. => **메시지 브로커가 적합**
  - 하지만, `알림 기반 무효화`를 위해 **메시지 브로커를 사용**하는 것은 과한 조치이다.
- `알림 기반 무효화` **사용시 유의점**은, 클라이언트가 **알림 메커니즘이 실제 정상 작동**하고 있는지 알 필요가 있다.
  - 알림 메커니즘을 통해 심박(heartbeat) 이벤트를 전송하여 알림이 계속 수신되고 있는지 확인할 수 있다.
- 알림에 포함된 내용도 고려해야 한다.
  - 알림에 많은 데이터가 포함되면 **크기와 관련된 문제**가 발생할 수 있고, **민감한 데이터가 광범위하게 노출**될 수 있다.

#### [연속 쓰기]
- `연속쓰기 캐시(Write-Through Cache)`는 원본의 상태와 동시에 캐시가 업데이트되는 방식이다.
- 일반적으로 마이크로서비스 아키텍처에서 서버 측 연속 쓰기 캐시가 사용된다.

#### [나중 쓰기]
- `나중쓰기 캐시(write-behind cache)`는 캐시가 먼저 업데이트된 다음 원본이 업데이트 되는것이다. (캐시는 버퍼의 개념)

### 13.4.6 캐싱의 황금 법칙
### 13.4.7 신선도 대 최적화
### 13.4.8 캐시 중독:주의해야 할 이야기

## 13.5 자동 확장
## 13.6 다시 시작하기

## 요약






![1](./images/ch13/img.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

mysql 샤딩
https://www.youtube.com/watch?v=8Eb_n7JA1yA
