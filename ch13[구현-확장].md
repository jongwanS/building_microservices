# 13 확장
- 시스템 확장 2가지 이유
  - **더 많은 부하** 처리, **지연시간 개선**
  - **시스템 견고성 개선**

## 13.1 확장의 네가지 축
- 확장 육면체(Scale Cube), `The Art of Scalability`
  - https://chanwookpark.github.io/microservice/scalecube/%EB%B2%88%EC%97%AD/chris/2014/04/12/scale-cube/

- **수직 확장(vertical scaling)**
  - 더 큰 머신을 사용하는 것
- **수평 복제(horizontal duplication)**
  - 동일한 작업을 수행하는 여러 대의 기기를 두는 것(인스턴스 추가)
- **데이터 파티셔닝(data partitioning)**
  - 데이터의 일부 속성에 따라 작업을 나누는 것.
- **기능 분해(functional decomposition)**
  - 마이크로서비스와 같이 업무를 분리하는 것.

### 13.1.1 수직확장
- 큰 머신을 사용하면 **지연 시간**(latency)과 **처리량**(throughput)이 향상돼 시간 대비 더 많은 작업을 처리할 수 있다.
- 과거에는 수직확장을 위해 하드웨어 구매, 실제 필요한 크기보다 더 큰 규모로 정하는 일이 흔했다.
- 가상화&클라우드 등장으로 확장이 수월 해졌다.

#### [구현]
- 구현 방법은 실행 중인 인프라스트럭처에 따라 다르다.
  - `가상화` => VM 크기 조정
  - `베어메탈(bare metal) 서버` => 더 좋은 하드웨어 구매
    - 베어메탈 : 한 소비자 또는 테넌트만 사용하는 물리적 컴퓨터 서버
  - `클라우드` => 목적에 맞는 다양한 머신 선택, 간단하고 빠르게 확장 가능

#### [주요 이점]
- 가상화된 인프라스트럭처(공용 클라우드 제공업체) 수직확장을 빠르게 구현 할 수 있다.
  - 시스템 개선 아이디어를 얻고, 변경을 수행하며, 그 영향을 측정 => 실험을 빠르고 안전하게 시도할 수 있다.
- 수직 확장을 통해 다른 확장 유형들을 더 쉽게 수행 가능 하다.
  - 데이터베이스 인프라스트럭처를 더 큰 머신으로 옮기면, 논리적 데이터베이스(마이크로서비스용)를 더 많이 호스팅 가능하다.
- 수직 확장시 코드나 데이터베이스를 변경할 필요 없다.
  - 변경된 하드웨어 활용시, 런타임 플래그로 메모리양을 늘릴 수 있다.

#### [제한 사항]
- CPU 클럭 속도 향상이 둔화되고, 코어 수가 증가하는 추세이다.
  - 소프트웨어가 멀티코어 하드웨어를 활용하지 못하는 경우가 많다.
- 더 큰 시스템이 무조건 **견고성을 개선하지는 않는다.**
- 더 큰 머신일수록 비용이 증가하지만, 가용 자원이 증가가 항상 비례하지는 않는다.
  - 소수의 대형 머신보다 다수의 소형 머신이 더 비용 효과적일 수 있다.

### 13.1.2 수평 복제
- 수평복제는 단순한 편에 속하며, 초기에 시도하는것 중 하나다.
  - 모놀리식 시스템 부하가 있다면, 수평 복제를 시도하는 것도 좋은 방법이다.

#### [구현]
- 로드 밸러서를 통해 여러 복제본으로 요청 분산
  - 최근에는 더 많은 로드 밸런싱이 클라이언트 측에서 실행되는 경우가 많다. (envoy)
  ![1](./images/ch13/img.png)    
  출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

- [그림 13-2] 뮤직코프에 새로운 노래가 업로드 되는 사진이다.
  - 노래 트랜스코더 서비스 인스턴스들이 작업을 두고 경쟁
  - 처리량 증가를 위해 인스턴스를 추가할 수 있다.
  ![1](./images/ch13/img_1.png)     
  출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축

- [그림 13-3] 푸드코의 DB 수평복제
  - 읽기 복제본 라우팅은 마이크로서비스 내부적으로 처리
  ![1](./images/ch13/img_2.png)    
  출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

#### [주요 이점]
- 수평 복제는 비교적 간단하다.

#### [제한 사항]
- 많은 인프라스트럭처가 필요 => 더 많은 비용 발생
- 수평복제는 부하 분산 매커니즘이다
  - 고정 세션이 필요한 경우 부하 분산 메커니즘이 제한될 수 있다. 

### 13.1.3 데이터 파티셔닝
- `데이터 파티셔닝`은 데이터의 일부 측면을 기반으로 부하를 분산시킨다.
#### [수평]
![1](./images/ch13/horizontal_partitioning.png)    
출처 : https://www.baeldung.com/cs/databases-horizontal-vertical-partitioning  
#### [수직]
![1](./images/ch13/vertical_partitioning.png)    
출처 : https://www.baeldung.com/cs/databases-horizontal-vertical-partitioning  
#### [샤딩]
![1](./images/ch13/horizontal_example.png)
출처 : https://www.youtube.com/watch?v=P7LqaEO-nGU  
![1](./images/ch13/sharding.png)
출처 : https://www.youtube.com/watch?v=P7LqaEO-nGU  
#### [replica]
![1](./images/ch13/replica.png)
출처 : https://www.youtube.com/watch?v=P7LqaEO-nGU

#### [구현]
[키에 함수를 적용한 파티션 ]
- 워크로드와 관련된 키를 가져온 후, `키에 함수를 적용`하여 **얻은 파티션(샤드)에 부하를 분산**
- 예를들어, [그림 13-4] 성을 기준으로 두 파티션으로 나눠 부하를 분산한다.  
![1](./images/ch13/img_3.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

[인스턴스 레벨 파티셔닝]
- 인스턴스 수준에서 파티셔닝도 가능하다. 
- 인바운드 요청으로부터 프록시를 통해, 어떤 파티션에 매핑되어야 하는지 파악가능하다.
- 예를들어, [그림 13-5]는 고객 요청헤더에 이름을 통해 인스턴스 매핑 시킨다.  
![1](./images/ch13/img_4.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축

[지리적 기준 파티셔닝]
- 국가별 지역별로 파티션을 만들 수 있다.

#### [주요 이점]
- `데이터 파티셔닝`은 **트랜잭션 워크로드에 유용**하게 확장 가능하다.
  - 쓰기 제약이 있는 시스템의 경우 큰 개션 효과를 얻을 수 있다.(각 파티션이 독립적으로 트랜잭션을 처리하기 때문)
- `데이터 파티셔닝`은 **유지 보수 활동의 영향도와 범위**를 쉽게 줄일 수 있다.
  - 파티션별 업데이트, 다운타임이 필요한 작업도 단일 파티션별에만 영향
- `데이터 파티셔닝`은 **수평 복제와 함께 잘 동작**한다.
#### [제한 사항]
- `데이터 파티셔닝`은 **시스템 견고성을 개선하는 데 한계**가 있다.
  - 예를들어, 4개의 파티션중 하나의 파티션이 다운되면 25%의 요청은 실패하게 된다. 
  - 데이터 파티셔닝과 **수평 복제 기술을 결합**해 특정 **파티션의 견고성을 향상**시킬 수 있음
- `파티션 키`를 **올바르게 설정하는 것은 어렵다.**
  - 키를 잘못선정한다면, 부하가 고르게 분산되지 않을 수 있다.
  - 고객에게 부여된 고유 ID를 기반으로 파티셔닝 분할 => 부하를 균등하게 분산 가능성이 높다.

> 데이터베이스 선택 기준 책 추천 
> - NoSQL : 빅 데이터 세상으로 떠나는 간결한 안내서  

### 13.1.4 기능 분해
- `기능을 분해`하면 **독립적으로 확장**할 수 있다.
- [그림 13-6]은 주문 기능을 모놀리식 시스템에서 추출한 예시이다.
![1](./images/ch13/img_5.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  
#### [구현]
- 3장 참조.
#### [주요 이점]
- 워크로드를 분리했으므로, **인프라스트럭처의 크기를 조정**할 수 있다.
  - 부하가 크지 않은 기능은 소규모 머신에 배포할 수 있다.
  - 부하가 큰 경우 수평 복제를 통해 부하를 분산시킬 수 있다.
  - `비용 최적화`하는 데 유연성을 확보할 수 있다.
- 기능 분해를 통해 **다양한 기술을 사용할 기회**가 늘어난다.
  - `서비스 유형`에 맞는 **데이터베이스 선택** 등
#### [제한 사항]
- `기능 분해`는 **복잡**하며, 단기간에 이점을 제공하기 어렵다.
  - `프론트&백엔드 코드에 가장 큰 영향`을 미칠 수 있는 확장 방식이다.
- `기능 분해`는 **시스템의 전반적인 복잡성을 증가**한다.
  - 유지 관리, 견고성 확보, 확장 등 필요한 항목이 더 많아진다.
- 필자는 시스템 확장시 `기능적 분해 이전`에 **다른 가능성 부터 모두 고려**한다.

//TODO
## 13.2 결합모델

## 13.3 작게 시작하라

## 13.4 캐싱

### 13.4.1 성능을 위해

### 13.4.2 확장성을 위해

### 13.4.3 견고성을 위해

### 13.4.4 캐싱 위치
#### [클라이언트 측 캐싱]
#### [서버 측 캐싱]
#### [요청 캐시]

### 13.4.5 무효화
#### [TTL]
#### [조건부 GET]
#### [알림 기반]
#### [연속 쓰기]
#### [나중 쓰기]

### 13.4.6 캐싱의 황금 법칙
### 13.4.7 신선도 대 최적화
### 13.4.8 캐시 중독:주의해야 할 이야기

## 13.5 자동 확장
## 13.6 다시 시작하기

## 요약






![1](./images/ch13/img.png)    
출처 : 한빛미디어 - 마이크로서비스 아키텍처 구축  

mysql 샤딩
https://www.youtube.com/watch?v=8Eb_n7JA1yA